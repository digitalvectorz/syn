"""
Binary tarball handling code

 @license: GPL-3+
 @author:  Paul Tagliamonte <paultag@gmail.com>
 @author:  Johnathon Mlady <digitalvectorz@gmail.com>
 @date:    August 6th, 2011, 01:50 -0000

 This is an interface to the binary tarballs that are generated by
 `Syn.Synd` in a sane way. Also does some error checking and stuff.

 Example Usage:

 ```
 import Syn.BinaryTarball

 btbal = Syn.BinaryTarball.BinaryTarball("./bash-4.3.syn")
 print btbal.getPackageFullId()
 ```
"""
import Syn.Log
import Syn.Tarball
import Syn.Exceptions
import Syn.Policy.BinaryPackage as B
import Syn.Policy.SourcePackage as S
import Syn.Md5sum

import os.path
import tarfile

class BinaryTarball(Syn.Tarball.Tarball):
	"""
	This class provides clean access to a syn compiled 
	binary tarball. It's interface matches very closely with a
	.SourceTarball`, and provides similar functionality.
	"""

	def verify(self):
		"""
		Verify that the binary tarball is in good working shape,
		and has all the required files needed to consider it a
		valid binary tarball. Checksum shazbits should be checked
		as well. This is automagically called by the constructor.
		"""
		assert_exists = []

		for x in B.BINARY_DIR_REQ_FILES:
			assert_exists.append(x)

		for y in assert_exists:
			try:
				fd = self.readMember(y)
				crap = fd.read()
				if crap != "":
					Syn.Log.l(Syn.Log.PEDANTIC,"Exists: %s" % y)
					
			except KeyError as e:
				raise Syn.Exceptions.SynFormatException("Bad binary tarball (missing: %s)" % y)

		errors = self.verifyChecksums()
		if errors > 0:
			raise Syn.Exceptions.SynFormatException("Bad binary tarball (checksum failures: %s)" % errors)
		else:
			Syn.Log.l(Syn.Log.LOG,"MD5 Checksums Passed!")

	def verifyChecksums(self):
		"""
		Verify the MD5-Sum of all the files in the archive.
		"""
		chk = self.getFilesums()
		targs = Syn.Common.getTempLocation()
		Syn.Log.l(Syn.Log.VERBOSE,"Using temp loc: %s" % targs)
		self.tarball_target.extractall(targs)

		popdir = Syn.Common.getcwd()
		Syn.Sh.cd(targs)

		checksumErrors = 0

		for x in chk:
			md5 = chk[x]
			if md5 != Syn.Md5sum.md5sum(x):
				checksumErrors = checksumErrors + 1
				Syn.Log.l(Syn.Log.CRITICAL,"md5 error!!! -- %s" % x)
			else:
				Syn.Log.l(Syn.Log.PEDANTIC,"   md5 clear -- %s" % x)

		Syn.Sh.cd(popdir)
		Syn.Sh.rmdir(targs)
		return checksumErrors

	def getUpstreamTarballId(self):
		"""
		`getUpstreamTarballId` yanks the tarball name from the wget
		string, so that we can see what the tarball's name should
		be. This can be krufty in a BinaryTarball.
		@return: A String which contains the upstream .tarball's name.
		"""
		figgleforth = self.getMetablob()
		return os.path.basename(figgleforth["wget-url"])

	def getPackageFullId(self):
		"""
		`getPackageFullId` snags the package's full package identifier,
		in the format of package-n.m, where n.m is the release number,
		and package is the name of the package. If the package was
		"Bash", and the version was "4.2" the full ID would be:
		"bash-4.2". This is used for file strings etc.
		@return: The package's full String ID.
		"""
		figgleforth = self.getMetablob()
		return os.path.basename(figgleforth["package"] + "-" + figgleforth["version"])

	def packageize(self):
		"""
		XXX: Fixme
		"""
		shit = self.getMetablob()
		bpatr = Syn.PackageRegistry.PackageAttrs(
			shit['package'], shit['version'], shit['local-version'], shit['deps'])
		return bpatr

	def getMetablob(self):
		"""
		`getMetablob` digests the tarball and loads the JSON manifest
		so that we can play with it. `getPackageFullId` and
		`getUpstreamTarballId` use this to get the dict.
		@return: A dict with the key/values in the manifest.
		"""
		targs = Syn.Common.getTempLocation()

		Syn.Log.l(Syn.Log.VERBOSE,"Using temp loc: %s" % targs)

		self.tarball_target.extract(
			B.META_ROOT + "/" + B.METAFILE,
			targs
		)

		sbf = Syn.JsonBfile.JsonBfile(
			targs + "/" + B.META_ROOT + "/" + B.METAFILE
		)
		figgleforth = sbf.getContent()

		Syn.Sh.rmdir(targs)
		return figgleforth

	def getFilesums(self):
		"""
		`getFilesums` digests the tarball and loads the JSON filesums
		so that we can play with it.
		@return: A dict with the key/values in the filesums file.
		"""
		targs = Syn.Common.getTempLocation()

		Syn.Log.l(Syn.Log.VERBOSE,"Using temp loc: %s" % targs)

		self.tarball_target.extract(
			B.META_ROOT + "/" + B.FILESUMS,
			targs
		)

		sbf = Syn.JsonBfile.JsonBfile(
			targs + "/" + B.META_ROOT + "/" + B.FILESUMS
		)
		figgleforth = sbf.getContent()

		Syn.Sh.rmdir(targs)
		return figgleforth
